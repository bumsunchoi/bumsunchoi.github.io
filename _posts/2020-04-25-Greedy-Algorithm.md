```
layout: single
date: 2020-04-25 17:00 +0900
title: "Greedy Algorithm"
```

# Greedy Algorithm

### 1. 포스트 소개

***

* 이러닝에 과제가 업로드 되고, 필자가 어떤 과제인지 인지했을때는 솔직히 막막했다. 수업시간에 그리디 알고리즘을 배우고 쉽지 않은 녀석임을 느꼈기 때문이다.
* 쉽지 않은 녀석을 설명 해야 하기에 기본에 충실한 알고리즘을 찾는데 집중했다.

* 이 포스트는 그리디 알고리즘에 대해 조사하고 조사한 것 에대한 설명이 쓰여질 예정이다. 

***

### 2. 그리디 알고리즘 정의

***

* 그리디 알고리즘에서 그리디는 영어로 Greedy 이다. 즉 탐욕스러운 알고리즘이라는 뜻이다. 그리디 알고리즘의 개념을 알게 되면 탐욕스러운 알고리즘이라는 이름이 왜 지어졌는지 알 수 있다.
* 그리디 알고리즘은 어느 상황이 주어 지게 된다면, 그 상황에서 최선의 선택만 하기 때문에 탐욕스러운 알고리즘으로 불린다.
* 개념만으로는 이해하는데 무리가 있는 알고리즘이다. 그렇기 때문에 이제부터 그리디 알고리즘에 대한 예시를 보여주겠다.

***

### 3. 문제

***

![](https://k.kakaocdn.net/dn/cC3rRv/btqv4Rrtllv/NXF5Py7tDmYYbZr3f3bybK/img.png)

**어떤 알고리즘을 소개해야 쉽게 그리디 알고리즘에 접근 할 수 있을지를 중점적으로 생각하며 찾은 문제이다.**

출처 : [https://www.acmicpc.net/problem/1138][Baek-Joon]

["Baek-Joon"]: https://www.acmicpc.net/problem/1138

***

### 4. 문제 이해

>알고리즘 문제를 해결 하는데 가장 중요한 것은 문제에 대한 이해와 이해를 토대로 어떤 방향으로 갈지  정하는 것이라고 생각한다.
>
>문제를 보면 1부터 10까지인 N을 입력받고 그 N을 토대로 키를 1부터 N까지로 모두 다르게 만들어 준다. 사진의 입력창 2번째 줄을 보게 되면  키가 1부터 N까지인 N명의 사람들이  키가 1인 사람부터 기억하는 정보를 주게 되어 있다.
>
>위에 문제의 핵심은 자신보다 큰 사람이 왼쪽에 몇 명 있었는지가 주어지기 때문에 줄을 세울 때는 왼쪽부터 자신보다 큰 사람들을 지나 친 다음 비어있는 자리에 세우는 것이다. 키가 작은 사람부터 자리를 채우기 때문에 줄에서 비어있는 위치의 개수가 자신보다 큰 사람들이 들어갈 수 있는 위치 이기 때문이다.

### 5. 문제 설명

```
예제 입력값과 출력값을 토대로 문제를 설명해보자면 첫 줄에 4과 입력 되어있다. 4의 의미는 사람의 수가 4명이라는 뜻이다 . 2번째 줄에는 2 1 1 0 이 입력 되어 있다. 키가 작은 사람부터 왼쪽에 있는 사람 수를 나타낸 것이다.
```

1. 키가 1인 사람

   입력 값을 보면 키가 1인 사람 왼쪽 옆에는 자신보다 큰 사람이 2명이 있다는 뜻이다. 자신보다 큰 사람들이 왼쪽 옆으로 2명이 와야 하기 때문에 3번째 자리에 키가 1인사람을 세운다,

2. 키가 2인 사람

   키가 2인 사람 옆에는 자신보다 큰 사람이 1명 있다. 자신보다 큰 사람이 왼쪽 옆으로 1명 와야 하기 때문에 2번째 자리에 키가 2인 사람을 세운다.

3. 키가 3인 사람

   키가 3인 사람 옆에는 자신보다 큰 사람이 1명 있다. 자신보다 큰 사람이 왼쪽 옆으로 1명 와야 하기 때문에 0번째 위치에는 세울수 없다. 1,2번째는 앞에서 채웠기 때문에 3번째 위치에 세운다.

4. 키가 4인 사람

   키가 4인 사람 옆에는 자신보다 큰 사람이 0명 있다. 자신보다 큰 사람이 왼쪽 옆에는 없어야 하므로 가장 앞에 설 수있다. 그렇기 때문에 0번째 자리에 세운다.

### 6. 코딩

```
![Greedy](C:\Users\qjatj\OneDrive\바탕 화면\Greedy.jpg)import java.util.*;

public class Greedy {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        int[] arr = new int[n];
        int leftCount;

        for (int val = 0; val < n; val++) {
            leftCount = sc.nextInt();

            for (int i = 0; i < n; i++) {
              if (leftCount == 0 && arr[i] == 0) {
                    arr[i] = val + 1;
                    break;
                } else if (arr[i] == 0) {
                    leftCount--;
                }
            }
        }
        for (int f : arr) {
            System.out.print(f + " ");
        }
    }
}
```

![](C:\Users\qjatj\OneDrive\바탕 화면\Greedy.jpg)

생각보다 코딩의 길이는 길지 않았다. 

### 7. 결론

>위 문제의 풀이를 보면 모든 경우를 따져보지 않고 기준에 따라 그 상황에 맞는 최적의 결론을 순서대로 구한다. 이것을 통해 위에서 언급했던 그리디 알고리즘 개념과 겹친다는 것을 알 수 있다. 
>
>이 문제를 꼭 그리디 알고리즘을 통해서만 풀 수 있지는 않겠지만 만약, 수의 범위가 커졌다면 그리디 알고리즘을 통해 문제를 해결 하는 것이 매우 효율적일 것이다.
>
>하지만, 그리디 알고리즘을 사용할 때 마지막 결과과 최적의 결과라는 보장은 없다. 특수한 경우에만 적용 되기 때문이다.